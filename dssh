if [[ $0 != dssh || -n $ZSH_SCRIPT ]]; then
    0=${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}
    0=${${(M)0##/*}:-$PWD/$0}
    typeset ZSH_DSSH_DIR=${0:h}
fi

set +m
set -o pipefail

local WAS_UPDATED=false
local DEFAULT_PARAMETERS=( "-o ConnectTimeout=10" )
local PUBLIC_DNS_NAME_PATTERN="ec2-.+"

_usage() {
  echo
  echo "Locates and connects to AWS servers via SSH."
  echo
  echo "Usage: dssh [ssh options] [options] tags [tags ...]"
  echo ""
  _dssh_tag_usage
  echo "SSH OPTIONS:"
  echo "    Flags:   -4 | -6 | -A | -a | -C | -f | -G | -g | -K | -k | -M"
  echo "             -N | -n | -q | -s | -T | -t | -V | -X | -x | -Y | -y"
  echo "    Options: -B | -b | -c | -D | -E | -e | -F | -I | -i | -J | -L"
  echo "             -l | -m | -O | -o | -p | -Q | -R | -S | -W | -w"
  echo ""
  echo "OPTIONS:"
  echo "    --command=COMMAND               run the specified command and exit"
  _dssh_common_usage
}

_parse_parameter() {
  local shift_count=1
  case "$1" in
    -4 | -6 | -A | -a | -C | -f | -G | -g | -K | -k | -M | -N | -n | -q | -s | -T | -t | -V | -X | -x | -Y | -y)
      _dssh_add_ssh_option "$1"
    ;;
    -B | -b | -c | -D | -E | -e | -F | -I | -i | -J | -L | -l | -m | -O | -o | -p | -Q | -R | -S | -W | -w)
      _dssh_add_ssh_option "$1 $2"
      shift_count=2
    ;;
    -B\ * | -b\ * | -c\ * | -D\ * | -E\ * | -e\ * | -F\ * | -I\ * | -i\ * | -J\ * | -L\ * | -l\ * | -m\ * | -O\ * | -o\ * | -p\ * | -Q\ * | -R\ * | -S\ * | -W\ * | -w\ *)
      _dssh_add_ssh_option "$1"
    ;;
    -c=* | --command=*)
      command_string="${1#*=}"
    ;;
    -v | -vv | -vvv | -vvvv)
      _dssh_add_ssh_option "-$(printf 'v%.0s' {1..$verbose_level})"
    ;;
    *)
      if [[ "$1" =~ ^-[46AaCfGgKkMNnqsTtVXxYy]+$ ]]; then
        for char in $(echo "${1:1}" | fold -w1); do
          _parse_parameter "-$char"
        done
      else
        _dssh_parse_common_parameters "$1"
        shift_count=$?
      fi
    ;;
  esac
  return $shift_count
}

_dssh_prepare_dssh_locking

if [[ $# -eq 0 ]]; then
  _dssh_perror "wrong number of input parameters [$#]"
  _usage
  return $_dssh_e_noargs
fi

local python_installed=false
local refresh_enabled=false
local verbose_level=0
local ssh_options=()
local tags=()
local command_string=""
if ! _dssh_parse_parameters ".dsshrc" "$@"; then
  return $_dssh_e_noerror
fi

local addr=""
local desc=""
if [[ ${#tags[@]} -eq 1 && "${tags[1]}" =~ $_dssh_public_fqdn_target ]]; then
  addr="${tags[1]}"
else
  local info=""
  info="$(_dssh_resolve_target "${tags[@]}")"
  if [[ "$?" -eq 1 ]]; then
    WAS_UPDATED=true
  fi
  if [ -z "$info" ]; then
    _dssh_update_inventories
    info="$(_dssh_resolve_target "${tags[@]}")"
    if [[ "$?" -eq 1 ]]; then
      WAS_UPDATED=true
    fi
    if [ -z "$info" ]; then
      _dssh_pwarn "Host '${tags[*]}' not found in inventory.  Attempting to connect anyway..."
      addr="${tags[*]}"
    fi
  fi
  if [[ "$addr" == "" ]]; then
    local count=$(echo "$info" | wc -l)
    if [[ $count -gt 1 ]]; then
      if _dssh_is_inventory_old; then
        _dssh_update_inventories
      fi
      _dssh_prompt_server
      local result="$?"
      if [[ "$result" -eq -1 ]]; then
        return $_dssh_e_noerror
      elif [[ "$result" -gt 0 ]]; then
        return $result
      fi
    fi
    local public_addr=`echo $info | awk -F, '{print $2}'`
    local private_addr=`echo $info | awk -F, '{print $3}'`
    if _dssh_should_use_public_ip_address "$public_addr" "$private_addr"; then
      addr="$public_addr"
    else
      addr="$private_addr"
    fi
    local name=`echo $info | awk -F, '{print $1}'`
    desc=" ($name) [$(echo $info | awk -F, '{print $4}')]"
    if [[ "$addr" =~ $PUBLIC_DNS_NAME_PATTERN ]] && ! nc -G3 -z $addr 22 &>/dev/null; then
      if [[ "$WAS_UPDATED" == "false" ]]; then
        _dssh_update_inventories
        info="$(_dssh_resolve_target "$name")"
        if [[ "$?" -eq 1 ]]; then
          WAS_UPDATED=true
        fi
        if [[ "$info" == "" ]]; then
          info="$(_dssh_resolve_target "${tags[@]}")"
        fi
        _dssh_prompt_server
        local result="$?"
        if [[ "$result" -eq -1 ]]; then
          return $_dssh_e_noerror
        elif [[ "$result" -gt 0 ]]; then
          return $result
        fi
        addr=`echo $info | awk -F, '{print $2}'`
        desc=`echo $info | awk -F, '{print "(" $1 ") [" $3 "]"}'`
      fi
    fi
  fi
fi

if [[ "${addr}" == "" ]]; then
  _dssh_pverbose "No server was found"
  return $_dssh_e_noserver
fi

echo "" 1>&2
local connection_message="Connecting to"
local -a ssh_command=( "ssh" )
if [[ "$command_string" != "" ]]; then
  connection_message="Running command \`$command_string\` on"
fi
if [[ "${#ssh_options[@]}" -gt 0 ]]; then
  read -rA opts <<<"${ssh_options[@]}"
  for opt in "${opts[@]}"; do
    ssh_command+=( "$opt" )
  done
fi
ssh_command+=( "${addr}" )
if [[ "$command_string" != "" ]]; then
  ssh_command+=( "${command_string}" )
fi
_dssh_pverbose "$connection_message ${addr}${desc}..."
${ssh_command[@]}
return $?